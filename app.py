import requests
import math
from bs4 import BeautifulSoup
import logging

from flask import Flask, request
from flask import jsonify

CO2_EMISSION_MWH = 0.3
CO2_PRICE_PER_TON = 150

app = Flask(__name__)

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

handler = logging.FileHandler('app.log')
handler.setLevel(logging.INFO)

formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)

logger.addHandler(handler)

@app.route("/")
def index():
    return app.send_static_file("index.html")

@app.route('/productionplan' , methods=['POST'])
def production_plan():
    # Get input data from the request body
    data = request.get_json()
    load = data['load']
    fuels = data['fuels']
    powerplants = data['powerplants']

    logger.info(f"Received request with load = {load}, fuels = {fuels}, powerplants = {powerplants}")


    # Calculate the merit order based on fuel prices and efficiency
    production_cost(powerplants,fuels)
    merit_order = sorted(powerplants, key=lambda x: (
        x['variable_cost'],
        -x['pmax'],
        x['emissioncost'])
    )

    # Calculate the power output of each power plant
    power_output = {}
    total_power = 0
    for plant in merit_order:

        if total_power >= load:
            break

        pmax = plant['pmax']
        efficiency = plant['efficiency']
        power_produced = pmax * efficiency
        total_power += power_produced
        power_output[plant['name']] = power_produced

    # Ensure that the sum of the power generated by all power plants equals the given load
    total_power = sum(power_output.values())

    if total_power < load:
        response = f"Required demand can not be met, load: {load} total_power: {total_power}"
        logger.warn(f"Sending response with = {response}")
        return jsonify(response)

    elif total_power > load:
        pmin_values = {plant['name']: plant['pmin'] for plant in powerplants}
        excess_power = total_power - load
        while excess_power > 0:

            for plant_name, power in sorted(power_output.items(), key=lambda x: x[1], reverse=True):

                reduce_by = min(power, excess_power)
                # can the power output of a windturbine be decreased ?
                
                if ((power_output[plant_name] - reduce_by) > pmin_values[plant_name]):
                    power_output[plant_name] -= reduce_by
                else:
                    power_output[plant_name] = pmin_values[plant_name]

                total_power = sum(power_output.values())
                excess_power = total_power - load

                if excess_power == 0:
                    break

    # Ensure that the power produced by each power plant is a multiple of 0.1 MW
    for plant_name, power in power_output.items():
        power_output[plant_name] = math.floor(power * 10) / 10

    # Return the output data in the JSON format

    logger.info("Sending response with = %s", power_output)
    return jsonify(power_output)

def production_cost(powerplants, fuels):
    for plant in powerplants:
        match plant['type']:
            case 'gasfired':
                fuel_price = fuels['gas(euro/MWh)']
                plant['emissioncost'] = plant['pmax'] * CO2_EMISSION_MWH * CO2_PRICE_PER_TON
            case 'turbojet':
                fuel_price = fuels['kerosine(euro/MWh)']
                plant['emissioncost'] = plant['pmax'] * CO2_EMISSION_MWH * CO2_PRICE_PER_TON
            case 'windturbine':
                fuel_price = 0
                #pmax Ã  adapter en fonction du vent
                plant['pmax'] = plant['pmax'] * (fuels['wind(%)'] / 100)
                plant['emissioncost'] = 0
        efficiency = plant['efficiency']
        plant['variable_cost'] = fuel_price / efficiency
    return powerplants

